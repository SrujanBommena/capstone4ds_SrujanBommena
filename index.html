<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="literature-review" class="level1">
<h1>LITERATURE REVIEW</h1>
<section id="quantifying-and-explaining-machine-learning-uncertainty-in-predictive-process-monitoring" class="level2">
<h2 class="anchored" data-anchor-id="quantifying-and-explaining-machine-learning-uncertainty-in-predictive-process-monitoring">Quantifying and Explaining Machine Learning Uncertainty in Predictive Process Monitoring</h2>
<section id="background-motivation" class="level3">
<h3 class="anchored" data-anchor-id="background-motivation">BACKGROUND / MOTIVATION :</h3>
<section id="context" class="level4">
<h4 class="anchored" data-anchor-id="context">CONTEXT</h4>
<p>The entire framework of speculative process monitoring lies at the juncture between artificial intelligence (AI) and operations research (OR) under complicated industrial environments. Businesses are heavily reliant on their decision-making processes driven by data, so they want to compete well. Since predictive models typically overlook the various uncertainties that characterize real-world processes, their relevance in circumstances that might rapidly evolve appears to be limited. This research aims to tackle critical issues in predictive analytics, particularly in production planning, by fusing explainability and uncertainty quantification (UQ) into machine learning (ML) workflows.</p>
</section>
<section id="problem-or-gap-in-the-existing-literature" class="level4">
<h4 class="anchored" data-anchor-id="problem-or-gap-in-the-existing-literature">PROBLEM OR GAP IN THE EXISTING LITERATURE</h4>
<ul>
<li><p>The neglect of data-driven estimation of technical production parameters, with many studies relying on assumptions or intuition.</p></li>
<li><p>The dominance of deterministic predictive models that do not consider uncertainty, limiting their reliability in real-world scenarios.</p></li>
<li><p>The lack of methods to explain sources of uncertainty in predictions, which hinders their practical application and acceptance by stakeholders.</p></li>
</ul>
</section>
<section id="significance-of-research-question" class="level4">
<h4 class="anchored" data-anchor-id="significance-of-research-question">SIGNIFICANCE OF RESEARCH QUESTION</h4>
<p>The research aims to integrate uncertainty quantification and explainability into predictive analytics for production planning, addressing the limitations of traditional models. This enhances the reliability, transparency, and utility of predictive analytics, enabling more informed and effective decision-making in dynamic manufacturing environments.</p>
</section>
</section>
<section id="methods-used" class="level3">
<h3 class="anchored" data-anchor-id="methods-used">METHODS USED</h3>
<section id="methods-and-uses" class="level4">
<h4 class="anchored" data-anchor-id="methods-and-uses">METHODS AND USES</h4>
<p>The overview of the whole process used in the analytics is summarized as a picture below;</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/image1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="600"></p>
</figure>
</div>
<p>1 Quantile regression forests (QRF) is a more general method of random forests that gives prediction intervals. QRF provides prediction intervals for uncertainty quantification.</p>
<p><span class="math display">\[ \[
w_i(x, \theta) =
\frac{1\{X_i \in R_\ell(x, \theta)\}}
{\sum_{j : X_j \in R_\ell(x, \theta)} 1}
\] \]</span></p>
<p><span class="math display">\[ \[
w_i(x) = k_1 \sum w_i(x, \theta_t)
\] \]</span></p>
<p>2 SHAP provides explanations of the contribution of individual input features to predictively uncertain clearness. It also enhances explainability by identifying key predictor features.</p>
<p><span class="math display">\[
g(z_0) = 0 + \sum_{i} \alpha_i z_0^i
\]</span></p>
<p>EXACT SHAP VALUES :</p>
<p><span class="math display">\[ \[
x_0 (z_0) = \frac{M - 1}{\binom{M}{|z_0|}\cdot |z_0| \cdot (M - |z_0|)} \]</span></p>
<p>3 Process-aware information systems (PAIS) leverage manufacturing execution systems data to build comprehensive event logs for predictive modeling in general. PAIS grounding the model in real-world data captures production process complexity and variability.</p>
</section>
<section id="techniques-and-approaches" class="level4">
<h4 class="anchored" data-anchor-id="techniques-and-approaches">TECHNIQUES AND APPROACHES</h4>
<p>Using SHAP to explain prediction intervals instead of point predictions lends greater insight into the sources of uncertainty. Your response will normally go into further detail about the fact that the uncertainty may be profiled as low, medium, and high, though this will enable targeted interventions and make better decisions on managing risk. The implementation of probabilistic estimations and explainability techniques on real-world production planning scenarios tightens the relationship between theory and practice.</p>
</section>
</section>
<section id="significance-of-the-work" class="level3">
<h3 class="anchored" data-anchor-id="significance-of-the-work">SIGNIFICANCE OF THE WORK</h3>
<section id="key-findings-and-contributions" class="level4">
<h4 class="anchored" data-anchor-id="key-findings-and-contributions">KEY FINDINGS AND CONTRIBUTIONS</h4>
<ol type="1">
<li>In QRF predictive intervals, higher reliability has been obtained, attaining 90 Percent PuC for test datasets.</li>
<li>SHAP analysis indicates that production quantity, material properties, and historical processing times had a direct impact on prediction intervals.</li>
<li>Uncertainty quantification gives added benefits for decision-making in areas with very high uncertainty.</li>
<li>The confluence of uncertainty quantification and explainable artificial intelligence brings about models that profile accuracy and interpretability.</li>
</ol>
</section>
<section id="implications-and-broader-context" class="level4">
<h4 class="anchored" data-anchor-id="implications-and-broader-context">IMPLICATIONS AND BROADER CONTEXT</h4>
<p>The approach can be integrated with optimization approaches to improve decision-making in the face of uncertainty, making it extremely useful for prescriptive analytics. To ensure that decisions are resilient to variability, the QRF model’s outputs, for example, can be immediately integrated into optimization frameworks for scheduling, resource allocation, or inventory management. The significance of explainability in fostering confidence in machine learning systems is further highlighted by this study. It enables users to verify model predictions and pinpoint possible areas for development by offering insights into the factors that contribute to uncertainty. This is especially crucial in high-stakes industries like manufacturing, where choices made using inaccurate or ambiguous models may have serious operational or financial repercussions. extending the paradigm to further fields where uncertainty is crucial, like healthcare or supply chain logistics.</p>
<p>SHAP summary plots for “low,” “medium,” and “high” uncertainty profiles, showcasing differences in feature impacts under varying levels of uncertainty</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/image2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="600"></p>
</figure>
</div>
<p><img src="images/image3.png" class="img-fluid" width="600"></p>
<p>This gives representation of the other usage of the given method in new fields, for instance health care and supply chain logistics.</p>
</section>
</section>
<section id="work-connections" class="level3">
<h3 class="anchored" data-anchor-id="work-connections">WORK CONNECTIONS</h3>
<section id="papaer-relevance" class="level4">
<h4 class="anchored" data-anchor-id="papaer-relevance">PAPAER RELEVANCE</h4>
<p>Predict-then-optimize and Explainable AI are two approaches adopted in Operations Research (OR) to amplify decision-making. Predict-then-optimize uses predictive analytics to forecast an event and/or behavior of a system to determine the most viable course of action with the use of optimization models. Explainable AI aims to transform complex OR models into more clear and comprehensible formulations that build trust and identify biases. Research in these areas utilizes such techniques as sensitivity analysis, local explanations, and counterfactual reasoning. Fundamental research on Random forests and SHAP aims to understand their strengths and limitations, properly identify potential biases, and work toward increased interpretability and explainability.</p>
</section>
<section id="differ-from-previous-works" class="level4">
<h4 class="anchored" data-anchor-id="differ-from-previous-works">DIFFER FROM PREVIOUS WORKS</h4>
<p>Predictive analytics has demonstrated its utility in estimating parameters within optimization models. However, the studies mainly presume an expected outcome and are thus less useful in the highly unpredictable context. To allow for the quantification of variability during the consequent optimization phase, uncertainty quantification is included into the prediction stage in this study.</p>
<p>HOW IT IS DIFFERENT FROM PREVIOUS WORKS : The study offers a fresh glimmer that has been spun around raw footages through publication after publication with a grain of prediction taken up on the foundation of deterministic outcomes.The development work, very clearly, offers a complete framework which raises the level of prescriptive analytics just to add predictive process monitoring into it, and integrates findings from several perspectives.</p>
</section>
</section>
<section id="my-project-relevance" class="level3">
<h3 class="anchored" data-anchor-id="my-project-relevance">MY PROJECT RELEVANCE</h3>
<p>This capstone project on Machine Learning and Predictive Analytics for outcome prediction via historical data should be considered a very promising way of quantifying and explaining uncertainty in predictions using Quantile Regression Forests (QRF) and the SHapley Additive exPlanations (SHAP) method. Whenever and wherever predictions based on event-based data are carried out, improved predictive accuracy functions to employ advanced preprocessing and feature engineering techniques. The methods themselves can feature multiple applications, particularly in health, retail, and financial forecasting. Continuous model updates help improve predictive accuracy and adaptability. The paper emphasizes the importance of combining predictive with prescriptive analytics in the decision-making process, which in turn gives practical recommendations to stakeholders.</p>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">REFERENCES</h3>
<p>[1] Simon, H.A.: The future of information systems. Annals of Operations Research 71(0), 3–14 (1997)</p>
<p>[2] Frazzetto, D., Nielsen, T.D., Pedersen, T.B., Sikˇsnys, L.: Prescriptive ana- lytics: a survey of emerging trends and technologies. The VLDB Journal 28, 575–595 (2019)</p>
<section id="name-sathwika-bairi" class="level4">
<h4 class="anchored" data-anchor-id="name-sathwika-bairi">NAME : SATHWIKA BAIRI</h4>
</section>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>